
<html>
	<head>
		<title>多项式时间 P，NP，NP-Hard，NP-Compete问题</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

	<!-- Header -->
	<header id="header">
		<a href="index.html" class="title">回主页咯！</a>
		<nav>
			<ul>
				<li><a href="index.html">Home</a></li>
				<li><a href="daily_study.html" class="active">daily study</a></li>
				<li><a href="elements.html">project</a></li>
			</ul>
		</nav>
	</header>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<section id="main" class="wrapper">
						<div class="inner">
							<h1 class="major">多项式时间 P，NP，NP-Hard，NP-Compete问题</h1>
							<span class="image fit"><img src=" " alt="" /></span>
							<h2>时间复杂度</h2>
							<p>时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。<br/>
								对于高速处理数据的计算机来说，处理某一个特定数据的效率不能作为衡量一个程序好坏的标准，而应该看当这个数据的规模不断扩大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍甚至数万倍。<br/><br/>
								<span class="image fit"><img src=" images/8d5d86ecb45043edb99825cebccd5632.png" alt="" /></span>
								图源自: <a href="https://www.bigocheatsheet.com/">bigocheatsheet.com</a><br/><br/>
								下面是常见的时间复杂度，它们与不同大小输入数据的性能比较：
								<span class="image fit"><img src="images/WechatIMG154.png " alt="" /></span>
							</p>
							<h2>多项式时间</h2>
							<p>多项式时间在决定型机器上是最小的复杂度类别，且在机器模型改变时依旧强韧，且也是可在副程式组合过程中保持封闭的类别。<br/>
								不管数据扩大多少，程序处理花费的时间始终是那么多的，我们就说这个程序很好，具有O(1)的时间复杂度，也称常数级复杂度，即花费时间为常数，数据规模的扩大不会改变花费时间； 数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是O(n)；
								而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于O(n^2)的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是O(a^n)的指数级复杂度，甚至O(n!)的阶乘级复杂度。<br/>
								不会存在O(2*n^2)这种带有系数的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。因此，我们会说，一个O(0.01*n^3)的程序的效率比O(100*n^2)的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终O(n^3)的复杂度将远远超过O(n^2)。我们也说，O(n^100)的复杂度小于O(1.01^n)的复杂度。<br/>
								<br/>
								简而言之来说就是：像O(1),O(log(n)),O(n^a)等这种指数时间，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是O(a^n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。

							</p>
							<h2>P，NP，NP-Hard，NP-Compete问题</h2>
							<p>P(Polynomial,多项式)问题.P问题是可以在多项式时间内被确定机(通常意义的计算机)解决的问题.NP(Non-Deterministic Polynomial, 非确定多项式)问题,是指可以在多项式时间内被非确定机(他可以猜,他总是能猜到最能满足你需要的那种选择,如果你让他解决n皇后问题,他只要猜n次就能完成----每次都是那么幸运)解决的问题.
							<br/>简单的说，存在多项式时间的算法的一类问题，称之为P类问题；在多项式时间内可由非确定机解决的一类问题，称之为NP问题。另外，很多人相信P类问题是NP问题的一个子集，但既没有人证明出有某个问题属于NP但不属于P，也没有人证明所有NP问题都能在多项式时间内有解。<br/>
							</p>
							<h3>P问题</h3>
							<p>一个问题可以在多项式（O(n^k)）的时间复杂度内解决</p>
							<h3>PN问题</h3>
							<p>一个问题的解可以在多项式的时间内被证实或证伪</p>
							<h3>PN-Hard问题</h3>
							<p>任意np问题都可以在多项式时间内归约为该问题。归约的意思是为了解决问题A，先将问题A归约为另一个问题B，解决问题B同时也间接解决了问题A。</p>
							<h3>PN-Compete问题</h3>
							<p>既是NP问题，也是NP-Hard问题</p>
							<h3>相互关系：</h3>
							<p>显然，所有P问题都是NP问题，反之则不一定。npc问题是np问题的子集，也是p问题和np问题的差异所在。如果找到一个多项式内能被解决的npc问题的解决方法，那么P=NP。</p>

							<span class="image fit"><img src="images/20171025104808974.png " alt="" /></span><br/>
							<h2>给一些爱追根溯源的小朋友：</h2>
							<h3>关于NP：为什么验证一个答案的正确性这么重要？</h3>
							<p>因为最开始的时候都是数学家在搞这个，对于数学家来说如果有一个机器能帮助他们证明各种定理那就爽了。数学家经常干的两件事：1. 给出证明 2. 验证某个证明是不是对的。直觉上肯定验证更容易一些，但如果somehow可以证明NP=P，也就是说 验证 和 给出证明 其实在数学上是等价的，那么这个证明很可能给出了如何把 验证一个证明是否正确（NP）转化为 如何给出一个证明（P）的方法，从此以后数学家只要思考如何验证证明的正确性就能自动得到证明了，那不爽炸了。那个时候密码学的重要性只是崭露头角，但即使是在数学上的重要性，也足够让这个定义吸引人了。</p>
							<h3>关于NP-complete，为什么要单独把NP里最难的问题拿出来</h3>
							<p>最开始的时候，大家不知道NP的定义是存在所谓 最难的 这么一个东西的，各类问题没有固定的比较标准。搞不好就没有这么一个最难的东西。直到一个叫Cook的数学家做了点CS的工作，最后还悲惨的没拿到教职，用教授的话说：“He's in the wrong department.” 他证明了任何一个NP形式的问题都可以转换成 3SAT （某个NP问题），3SAT 就是说有n个variable，m个clause，每个clause都是某三个variable 或（|） 在一起， 最后再把所有的clause 和（&） 在一起， 问题是：“有没有一种对于这n个variable的取值可以让整个boolean formula的值为true？” 3SAT 这个问题的优点在于它非常的直观清晰。最开始这篇文章没得到什么重视，直到一个非常出名的计算机科学家Levin看到了这篇文章，突然意识到如果这么多问题都等价于 3SAT 问题，那这就很好地揭示了为什么之前那么多算法问题都找不到快速的（多项式级）算法，因为都和3SAT一样难嘛；另外可以用 3SAT 作为对各种计算问题的分界线，那以后只要发现是NP-complete的问题，大家就不用对于每个问题找解法了。由此衍生了很多对于complexity class的研究，而cook-levin这种把NP问题化为3SAT的思想一次又一次起到了至关重要的作用。</p>
							<h3>常见误区：NP=指数级算法？</h3>
							<p>不是的,NP强调的是：易于验证答案的正确性;而指数级算法是指得：存在一个图灵机可以在指数时间内给出答案。<br/>
								如果熟悉了NP的定义，会发现明显指数级问题包含NP问题（？）因为根据上面的定义，只要验证对一个输入x是否存在一个u能够被某个图灵机M验证就好了，那么在指数时间内，我们可以定义一个hardcode了所有M的信息的图灵机N，N尝试所有可能的u，看有没有哪个u能迫使M接受x。由于u是多项式长度，这种尝试可以在指数时间内结束。</p>>
							<h3>以上参考于：</h3>
							<p><a href="https://blog.csdn.net/fzp95/article/details/78338177">https://blog.csdn.net/fzp95/article/details/78338177</a></p>
							<p><a href="https://www.zhihu.com/question/24653072">知乎：能否用通俗的语言解释『多项式时间』</a></p>


						</div>
					</section>

			</div>

		<!-- Footer -->
			<footer id="footer" class="wrapper style1-alt">
				<div class="inner">
					<ul class="menu">
						<li>Design: <a href="index.html#three">小布啦</a></li>
					</ul>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>